<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>
  <meta name="generator" content="HTML Tidy for Windows (vers 14 February 2006), see www.w3.org">

  <title>Dynamic C++ Objects - Sample</title>
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
  <meta content="MSHTML 6.00.2900.2963" name="GENERATOR">
  <link rel="stylesheet" type="text/css" href="sqs.css">
</head>

<body>
  <table summary="" style="width: 600px; height: text-align: left;" border="1" cellpadding="2" cellspacing="2">
    <tbody>
      <tr>
        <td class="contents">  <br>
          <h2>
              DynObj - C++ Cross platform plugin objects
          </h2>
          <h3>A sample: Plugin + application</h3>
          Here we will create a couple of plugin libraries and use them from a simple main application. It wil demonstrate how to instantiate plugin objects, how to use plugin objects as ordinary C++ classes, how to query for supported types.          <br><br>
          <h3>Creating an interface file</h3>
          We start out with defining a simple interface file that manages data about a person (<em>PersonI.h</em>):
          <p class="code">
		#include &lt;string.h&gt;     // We use strcmp below <br>
		class DynStr; <br>
		
		// %%DYNOBJ class(DynI)  &nbsp;&nbsp;<strong>&lt;---Directive to pdoh preprocessor</strong> <br>
		class PersonI : public DynObj {  <br>
		public:  <br>
		&nbsp;&nbsp;&nbsp;// DynI methods &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>&lt;---Implement GetType and Destroy - for all DynObj:s</strong> <br> 
		&nbsp;&nbsp;&nbsp;virtual DynObjType* docall doGetType( ) const;  <br>
		&nbsp;&nbsp;&nbsp;virtual void docall doDestroy( ) { delete this; }
		 <br><br>
		&nbsp;&nbsp;&nbsp;// PersonI methods &nbsp;&nbsp;&nbsp;<strong>&lt;---Add our new methods</strong> <br>
		&nbsp;&nbsp;&nbsp;virtual const char* docall GetName( ) const = 0; <br>
		&nbsp;&nbsp;&nbsp;virtual int docall GetAge() const = 0; <br>
		 <br>
		&nbsp;&nbsp;&nbsp;virtual bool docall SetName( const char *name ) = 0;  <br>
		&nbsp;&nbsp;&nbsp;virtual bool docall SetAge(int age) = 0; <br><br>
		
		&nbsp;&nbsp;&nbsp;// <strong>---Simple default inline implementation of operator</strong><br> 
		&nbsp;&nbsp;&nbsp;virtual bool docall operator&lt;( const PersonI&amp; other ) const {   <br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return strcmp(GetName(),other.GetName()) &lt; 0;  <br>
		&nbsp;&nbsp;&nbsp;} <br>
		 <br>
		&nbsp;&nbsp;&nbsp;// <strong>---Non-virtual, inline convenience function</strong><br> &nbsp;&nbsp;&nbsp;// Derived cannot override.  <br>
		&nbsp;&nbsp;&nbsp;PersonI&amp; operator=( const PersonI&amp; other ) {  <br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SetAge( other.GetAge() );  <br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SetName( other.GetName() );  <br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return *this; <br>
		&nbsp;&nbsp;&nbsp;}  <br>
		}; <br>
          </p>
          Then, from a command prompt/shell,  we run the <em>pdoh</em> preprocessor on this file (the <strong>-o</strong> option tells the parser to write generated code directly into the file instead of to <em>stdout</em>):
          <p class="code" >
          $ ./pdoh PersonI.h -o <br>
          $ 
          </p>
          Looking at the header file, we see that a section at the beginning of the file has been added: 
          <p class="code">
          // %%DYNOBJ section general <br>
	  // This section is auto-generated and manual changes will <br>
          // be lost when regenerated!!<br><br>
	  #ifdef DO_IMPLEMENT_PERSONI<br>
  	  #define DO_IMPLEMENTING     // If app has not defined it already<br>
	  #endif<br>
	  #include "DynObj/DynObj.h"<br><br>
	  // These are general definitions &amp; declarations used <br>
          // on both the user side [main program]<br>
	  // and the implementor [library] side. <br>
	  <br>
	  // --- Integer type ids for defined interfaces/classes ---<br>
	  #define PERSONI_TYPE_ID 0x519C8A00<br>
	  <br>
	  // --- Forward class declarations ---<br> 
	  class PersonI;<br>
	  <br>
	  // --- For each declared class, doTypeInfo template specializations ---<br>
	  // This allows creating objects from a C++ types and in run-time casts<br>
	  DO_DECL_TYPE_INFO(PersonI,PERSONI_TYPE_ID);<br>
	  <br>
	  // %%DYNOBJ section end<br>
          </p>
          This section provides the glue needed to convert from a C++ <em>PersonI</em> type to the type strings and type ID:s that are used across the plugin boundary. <br><br>
          If we would like to move this section we're free  to do that. The next time the preprocessor is run on the same file, it will keep the section where we put it.<br><br>
          We also see that code has been inserted at the end of the file:
          <p class="code">
  	  // %%DYNOBJ section implement <br>
	  // This section is auto-generated and manual changes <br>
          // will be lost when regenerated!! <br>
	  // ... comments <br>
	  <br>
	  // Define the symbol below from -only one place- in the project implementing <br>
	  // these interfaces/classes [the library/module].<br>
	
	  #ifdef DO_IMPLEMENT_PERSONI <br>
	  <br>
	  // Generate type information that auto-registers on module load <br>
	  DynObjType <br> g_do_vtype_PersonI("PersonI:DynObj",PERSONI_TYPE_ID,1,sizeof(PersonI)); <br>
	  // DynI::doGetType implementation for: PersonI <br>
	  DynObjType* PersonI::doGetType() const { <br>
	  &nbsp;&nbsp;&nbsp;return &g_do_vtype_PersonI; <br>
	  }<br>
	  #endif // DO_IMPLEMENT_... <br>
          </p>
          The preprocessor has inserted code to do two things:
 	  <ul><LI>Declare a <em>DynObjType</em> structure for our type.</LI>
          <li>It provides a default implementation of <em>doGetType()</em> for our class</li></ul>
          When we define the symbol DO_IMPLEMENT_PERSONI from a C++ source file, the code above ends up in that file.<br><br>

          <h3>Creating an implementation file</h3>
          Next we create a source file that implements the interface (<em>PersonImpl1.cpp</em>):
          <p class="code">
	  // This will cause PersonI class registration info to come in our file. <br>
	  #define DO_IMPLEMENT_PERSONI  <br>
	  #include "PersonI.h" <br>
	 <br>
	  // We're also implementing our class  <br>
	  #define DO_IMPLEMENT_PERSONIMPL1 <br>
	 </p>
         The defines above puts the class registration code into this source file. Each interface/type that is handled must be declared as a global registration structure <strong>once</strong>. The defines DO_IMPLEMENT_... correspond to class we're implementing in this file. 
         <p class="code">
	  // Declare the class to the pre-processor. <br>
	  // %%DYNOBJ class(dyni,usertype)   <br>
	  class PersonImpl1 : public PersonI {  <br>
	  public: <br>
         </p>
         Here we tell the preprocessor that a plugin class is being defined. The flag <em>usertype</em> informs it that this class can be instantiated by the host. Therefore it must generate a factory function for this type in the library section.
         <p class="code">
	  &nbsp;&nbsp;&nbsp;// DynObj methods  <br>
	  &nbsp;&nbsp;&nbsp;virtual DynObjType* docall doGetType( ) const;  <br>
	  &nbsp;&nbsp;&nbsp;virtual void docall doDestroy( ) { delete this; }  <br>
	 <br>
	  &nbsp;&nbsp;&nbsp;// PersonI methods  <br>
	  &nbsp;&nbsp;&nbsp;virtual const char* docall GetName( ) const { <br>
	  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return m_name;  <br>
	  &nbsp;&nbsp;&nbsp;} <br>
          &nbsp;&nbsp;&nbsp;...
         </p>
         The above implementats functions in <em>DynObj</em> and <em>PersonI</em>. Since we are inside a class <em>PersonImpl1</em> which definintion is never is exposed, we can generate the function bodies inside the class definition.
         <p class="code">
	    &nbsp;&nbsp;&nbsp;// Constructor, Init from a string: "Bart,45"  <br>
    	    &nbsp;&nbsp;&nbsp;PersonImpl1( const DynI* pdi_init ) : m_age(0) { <br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// We will do this setup slightly awkward now, and improve in  <br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// the following examples. <br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*m_name = 0;    // NUL terminated <br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...
         </p>
         The constructor for a DynObj always take a simple argument of type <em>const DynI*</em>. Since DynI can implement any interface, we can pass pretty much any type of data to the constructor. To pass simple data like <em>int/double/const char*</em> and friends, one can use an instance of template class DynData&lt;T&gt;.
         <p class="code">
	  protected:  <br>
	  &nbsp;&nbsp;&nbsp;// Need not really be protected since user of PersonI cannot look here anyway.  <br>
	  &nbsp;&nbsp;&nbsp;char m_name[NAME_MAX_LENGTH];  <br>
	  &nbsp;&nbsp;&nbsp;int  m_age;  <br>
	  };  <br>
	 <br>
	  // %%DYNOBJ library  <br>
          </p>
          The last comment tell the preprocessor that we want library code inserted at this location. In this library section it will put the factory functions and any glue needed to instantiate plugin objects to the host.<br><br>

          Next we run the parser on this source file (the <strong>-p</strong> option tells <em>pdoh</em> where it can find template code):
          <p class="code">
          $ ./pdoh PersonImpl1.cpp -o -p../ <br>
	  Found library insertion point <br>
	  $ </p>
          The parser has now inserted code that generates glue for library functions. The glue code can be included/excluded using <em>#define DO_MODULE</em>:
          <p class="code">
	  // %%DYNOBJ section library <br>
 	  ...<br>
	  // Only include below when compiling as a separate library<br>
	  #ifdef DO_MODULE<br>
 	  ...<br>
	  // The object creation function for this module <br>
	  extern "C" SYM_EXPORT DynObj* CreateDynObj( const char *type, int type_id, <br>
 	  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const DynI *pdi_init, int object_size ){<br>
	  &nbsp;&nbsp;&nbsp;...<br>
	  &nbsp;&nbsp;&nbsp;if( ((!strcmp(type,"PersonImpl1") || type_id==PERSONIMPL1_TYPE_ID)) || <br>
	  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((!strcmp(type,"PersonI") && type_id==PERSONI_TYPE_ID)) ){ <br>
	  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return new PersonImpl1(pdi_init); <br>
    	  &nbsp;&nbsp;&nbsp;}<br>
    	  &nbsp;&nbsp;&nbsp;DO_LOG_ERR1( DOERR_UNKNOWN_TYPE, ... );<br>
    	  &nbsp;&nbsp;&nbsp;return 0; <br>
	  }<br>
	  </p>
          After compiling, we can connect this as a plugin to a host application, the preprocessor has generated the bits and pieces that are required, both for the host and the plugin side.<br><br>
          <h3>A main application</h3>
          Finally we create the main application (<em>main1.cpp</em>) that uses the plugin: 
          <p class="code">
	#include &lt;stdio.h&gt; <br>
	#include &lt;stdlib.h&gt; <br>
	<br>
	// DynObj support <br>
	#include "DynObj/DynObj.h"<br>
	#include "DynObj/DynObjLib.h"<br>
	#include "DynObj/DoBase.hpp"<br>
	<br>
	// Interfaces we're using<br>
	#include "PersonI.h"<br>
	#include "ProfessionI.h"<br>
        <br>
	int main( ) { <br>
	&nbsp;&nbsp;&nbsp;// Check that things have started OK <br>
	&nbsp;&nbsp;&nbsp;if( !doVerifyInit() ){ <br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("Failed DoVerifyInit\n"); <br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit(-1); <br>
	&nbsp;&nbsp;&nbsp;} <br>
         </p>
        Now we want to start using the plugin. For this, we use DynObjLib which wraps a cross-platform run-time (DLL/SO) library loader (initial code for this came from <A href="http://www.codeproject.com/useritems/plat_ind_coding.asp">Boby Thomas</A>).<br><br>
        It is worth noting that the main application and the library are loosely linked, making it easy to implement on any platform that supports explicit run-time loading of binary libraries.
        <p class="code">
	&nbsp;&nbsp;&nbsp;// Load library <br>
	&nbsp;&nbsp;&nbsp;DynObjLib lpimpl1( "pimpl1", true ); <br>
	&nbsp;&nbsp;&nbsp;if( lpimpl1.GetState()!=DOLIB_INIT ){ <br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf( "Could not load library (pimpl1): status (%d)\n", <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lpimpl1.GetState() ); <br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit( -1 ); <br>
	&nbsp;&nbsp;&nbsp;}<br>
	<br>
	&nbsp;&nbsp;&nbsp;// Create object <br>
	&nbsp;&nbsp;&nbsp;PersonI *pp = (PersonI*)lpimpl1.Create("PersonI",PERSONI_TYPE_ID); <br>
	&nbsp;&nbsp;&nbsp;if( pp ) { <br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pp->SetName( "George" ); <br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pp->SetAge( 34 ); <br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...
        </p>
        We have instantiated the object the 'raw' way here, giving type name and ID to <em>DynObjLib</em>. After that, it is just to start using the object as any standard C++ object.<br><br>
        We next query the object for an interface using <em>do_cast</em>:
        <p class="code">
        &nbsp;&nbsp;&nbsp;ProfessionI *pi = do_cast&lt;ProfessionI*&gt;(pp); <br>
        &nbsp;&nbsp;&nbsp;if( pi ) <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;// Use the interface  <br>
        &nbsp;&nbsp;&nbsp;<br>
        &nbsp;&nbsp;&nbsp;pp->doDestroy();<br>
        &nbsp;&nbsp;&nbsp;return 0;<br>
	}<br>
        </p>
        The template do_cast&lt;T&gt; takes care of the details of checking if <em>ProfessionI</em> is supported. It transforms the C++ type to type name and ID.  Using type information from the plugin, it can walk the class layout and return an adjusted interface pointer.<br><br>
        It is important that any address offsets applied inside objects are always based on information from the plugin compiler.<br><br>
        When using an interface pointer returned in this way, we can only assume it is valid for the duration of the current function. We do not need to release it in any way.<br><br>
        Finally, we delete the object using <em>DynObj::doDestroy</em> (which will recycle it in the memory manager of the plugin that created it).<br><br>
        Further documentation <A href="DynObj-library.html">here</A>.
        </td>
      </tr>
    </tbody>
  </table><br>
</body>
</html>
