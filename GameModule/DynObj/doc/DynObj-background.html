<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>
  <meta name="generator" content="HTML Tidy for Windows (vers 14 February 2006), see www.w3.org">

  <title>Dynamic C++ Objects - Background</title>
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
  <meta content="MSHTML 6.00.2900.2963" name="GENERATOR">
  <link rel="stylesheet" type="text/css" href="sqs.css">
</head>

<body>
  <table summary="" style="width: 600px; height: text-align: left;" border="1" cellpadding="2" cellspacing="2">
    <tbody>
      <tr>
        <td class="contents">  <br>
          <h2>
              DynObj - C++ Cross platform plugin objects
          </h2>
          <h3>A C++ class</h3>
            We have this class definition: 
            <p class="code">
            class AnExample { <br>
            public: <br>
            &nbsp;&nbsp;&nbsp;    AnExmaple( int i ) : m_i(i) { } <br>
            &nbsp;&nbsp;&nbsp;    virtual int Add( int i ); <br>
            &nbsp;&nbsp;&nbsp;    int Sub( int i ); <br>
            &nbsp;&nbsp;&nbsp;    int Get( ){ return m_i; } <br>
            &nbsp;&nbsp;&nbsp;    bool operator &lt; (int i){ return m_i<i; } <br>
            &nbsp;&nbsp;&nbsp;    static int StaticFunc( ); <br>
            protected: <br>
            &nbsp;&nbsp;&nbsp;    int m_i; <br>
            };<br>
            </p>
            For linking (which is the key issue in dynamic loading), this applies to the members of <em>AnExample</em>: 
            <ul>
            <LI>The constructor <em>AnExample(int i)</em> is inline so it does not generate any linking</LI>
            <LI>The virtual function <em>int Add(int i)</em> is an entry in the VTable of the class. To the compiler and linker, it is an index in this table. </LI>
            <li>The function <em>Sub(int i)</em> does generates linking. It refers to a function implemented somewhere else.</li>
            <li><em>Get()</em> is an inline function and does not generate linking.</li>
            <li><em>operator &lt;</em> is also an inline function (no linking).</li>
            <li>The <em>StaticFunc()</em> member requires linking. This is true for any static member.
            <li>The member variable <em>m_i</em> is a type and offset into the binary object. It does not generate linking.</li>
            </ul>
            So, it seems it's only static members and functions that are both non-virtual and non-inline member that generate any linking!<br><br>

            <h3>VTables</h3>
            To clarify things here a bit we should remember what virtual functions are: 
            <ul><LI>
            Each class (that has one or more virtual functions) has a unique virtual function table (VTable).</LI>
            <li>The VTable is per type, not per instance.</li>
            <li>A pointer to the VTable (if the object has one) is always stored first in the object. It is often referred to as the VPTR.</li>
            <li>A virtual member function is at run-time an index into this VTable where the address of the function to use is stored.</li>
            <li>A derived class has a copy of the base class VTable first in its own VTable. The new functions it introduces are stored at the end of that copy.</li>
            </ul> 
            The VTable in itself is in itself a symbol located inside a DLL. However, if an object is instantiated from inside the DLL/SO that owns the VTable, this is not part of the link process either.<br><br>
            So it seems we have found some middle ground.<br><br>
 
          <h3>C++ Inheritance </h3>
          We have a class that uses inheritance:<br>
            <p class="code">
            class SideBaseClass { <br>
            public: <br>
            &nbsp;&nbsp;&nbsp;    virtual const char *GetPath( ); <br>
            &nbsp;&nbsp;&nbsp;    virtual bool SetPath( const char *path  ); <br>
            };<br><br>
            class MultiBaseClass : public AnExample, public SideBaseClass { <br>
            public: <br>
            &nbsp;&nbsp;&nbsp;    virtual int Add( int i ); <br>
            &nbsp;&nbsp;&nbsp;    virtual bool SetPath( const char *path  ); <br>
            protected: <br>
            &nbsp;&nbsp;&nbsp;    int m_j; <br>
            };<br>
            </p>
          <em>MultiBaseClass</em> has two base classes and overrides a function from each base class. From a run-time perspective, the inheritance boils down to the following object layout for an instance of <em>MultiBaseClass</em>: <br><br>
          <table>
           <TR><TD>&nbsp;&nbsp;word offset 0</TD><TD>&nbsp;&nbsp;VPTR for MultiBaseClass</TD></TR>
           <TR><TD>&nbsp;&nbsp;word offset 1</TD><TD>&nbsp;&nbsp;m_i (base class data)</TD></TR>
           <TR><TD>&nbsp;&nbsp;word offset 2</TD><TD>&nbsp;&nbsp;m_j (derived class data)</TD></TR>
           <TR><TD>&nbsp;&nbsp;word offset 3</TD><TD>&nbsp;&nbsp;VPTR for SideBaseClass</TD></TR>
          </table><br>
          The VTable for MultiBaseClass will be:<br><br>
          <table>
           <TR><TD>&nbsp;&nbsp;slot 0</TD><TD>&nbsp;&nbsp;MultiBaseClass::Add(int i)</TD></TR>
           <TR><TD>&nbsp;&nbsp;slot 1</TD><TD>&nbsp;&nbsp;SideBaseClass::GetPath( )</TD></TR>
           <TR><TD>&nbsp;&nbsp;slot 2</TD><TD>&nbsp;&nbsp;SideBaseClass::SetPath( const char *path)</TD></TR>
          </table><br>
          This object data layout can vary with compiler and data type (compilers have settings for padding and alignment). However, this is constant also between compilers:
          <ol>
            <LI>The VPTR (if any) is always stored first in the object.</LI>
            <LI>The first virtual function in a base class always occupies slot 0 in the VTable.</LI>
            <LI>Subsequently declared virtual functions stored in order of declaration.</LI>
          </ol>
          For derived classes, the following applies:
          <ol>
            <LI>A derived class inherits its default VTable from its first base class that has a VTable (call it main base class).</LI>
            <LI>New virtual functions are appended (in order of declaration) at the end of the default VTable.</LI>
            <LI>For other base classes with VTables (side bases), a full copy of the object is stored at an offset into the binary object, including a copy of side base class VTable.</LI>
            <LI>The VTable of side bases can be modified (functions are overridden) but it cannot be extended.</LI>
          </ol>
          This is the main picture, there are a couple of exceptions to above rules. They are:
          <ol>
            <LI>The ordering of overloaded functions in the VTable does not correspond with declaration order for some compilers (MSVC among others, for historical reasons).</LI>
            <LI>Virtual destructors are handled in different ways by different compilers. They cannot be directly invoked across a compiler and DLL/SO boundary.</LI>
          </ol>

          A central part of the DynObj framework is to account for offsets between multiple bases generated by potentially different compilers.<br><br>
          What is important to recognize here is that: <em>Inheritance (neither single nor multiple) does not generate any linking</em>. <br><br>
          
          <h3>Common ground defined</h3>
          A class definition:
            <ul>
            <LI>with one or more (non-template, non-virtual) base classes</LI>
            <LI>with any number of virtual functions</LI>
            <LI>with operators that are either virtual or inline</LI>
            <LI>and any inline function</LI>
            <li>with any non-static data members</li>
            </ul>
          can be reused and implemented by both a host application and a plugin. Furthermore, they can use eachothers implementations of these classes. Code made by one compiler may use such a class compiled from another.<br><br>
          For function members, this works all the time, also in the cross-compiler case. For data members, it works as long as the compilers on each side have used the same sizes and padding for the data members.<br><br>
          When moving (casting) between base classes, the address offset must at all times be calculated based on offsets generated by the source (plugin) compiler.
          <br><br>
          This common ground is of course in addition to the old <em>extern "C" MyFunction(...)</em> style. That is however an important part that we will make use of below.<br><br>
 
          <h3>The run-time link</h3>
          We know now that instances of a class fulfilling above spec can be used by both the host application and the plugin, without requiring a linking process. But how do we handle creation and destruction of object instances?<br><br>
          Since a call across the plugin boundary is essentially typeless, we cannot communicate the type directly to the plugin as a C++ type. 
          <br><br>
          <h4>Plugin object creation</h4>
          Say that from the host, we want the plugin to create an instance of <em>AnExample</em>:
          <p class="code">AnExample *pe = new AnExample; // This doesn't work </p> 
          This would just make the host instantiate it.<br><br>
          Since we don't have the compile time type machinery here, (remember, we're communicating with a binary module possibly from another compiler), we have to communicate the type to the plugin in some other way. <br><br>
          To solve this problem, we use a factory function in the plugin that take the type encoded as a string and an integer:
          <p class="code">
          extern "C" void* CreatePluginObject( const char *type_name, int type_id )<br>
          &nbsp;&nbsp;&nbsp; if( !strcmp(type_name,"AnExample") &amp;&amp;<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; type_id == ANEXAMPLE_TYPE_ID ) <br>
          &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return new AnExample;<br>
          &nbsp;&nbsp;&nbsp; else return NULL; <br>
          }<br>
	  </p>
          Then on the host side we can do:
          <p class="code">
          typedef void* (*PluginFactoryFn)(const char *type, int id);<br>
          <br>
          // First locate CreatePluginObject inside a loaded DLL<br>
          PluginFactoryFn create_fn = /* Locate it */; <br><br>
          // Now create object<br>
          AnExample *pae = (AnExample*)create_fn( "AnExample", <br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ANEXAMPLE_TYPE_ID );<br>
          </p><br>
          The DynObj framework automates this conversion step so that we can use the expression:
          <p class="code">AnExample *pe = do_new&lt;AnExample&gt;; // This works 
          </p> 
          to instantiate objects from inside plugins. The conversion:
          <ul><LI>C++ type => (type string,type ID)</LI></ul>
          is taken care of by templates classes available in the host application.
          <br><br>
          <h4>Plugin object destruction</h4>
          There are some points to consider here to keep cross-compiler compatibility:
          <ul>
          <LI>We cannot be sure that the host and the plugin share the same memory allocator (on Windows this is often not the case). So using C++ <em>delete</em> on plugin objects is not a good idea.</LI>
          <LI>Virtual destructors are used in different ways by different compilers.</LI>
          </ul>
          Essentially, the host must make sure a pluigin object is 'recycled' by the same plugin that created it. To handle this, the DynObj framework has used a solution where each object that is created has a virtual member function <em>doDestroy()</em>: 
          <p class="code">
          DynObj *pdo = /* Create object and use it */;<br>
          pdo->doDestroy(); // End of object 
          </p>
          We see here that we have used <em>DynObj</em> as a base class for objects that are created by a plugin. <br><br>
          The <em>DynObj</em> framework works with any classes, but objects that can be created and destroyed by plugins must derive from <em>DynObj</em>.
          <br><br>
          <h3>Linking revisited</h3>
          The solution with factory functions gives the responsability of setting up the VTable to the plugin, and so, all the functions we need from the plugin are contained in these pre-linked VTables. Each instantiated object comes back with a VPTR as its first binary member.<br><br>
          The only run-time linking we have to do is to lookup these factory functions inside the plugin DLL (and possibly some other init/exit functions).<br><br>
          This keeps the host and the plugin in a loosely coupled relationship, defined by the plugin interface.<br><br>
          Next comes the <A href="DynObj-solution.html">description of the DynObj solution</A> using this approach.
      </tr>
    </tbody>
  </table><br>
</body>
</html>
